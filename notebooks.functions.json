{"version":2,"kind":"Notebook","sha256":"555d7fa4572c813e2fe8ce14593211f32d54dcb97b9d368013c53de815edd2a2","slug":"notebooks.functions","location":"/notebooks/functions.ipynb","dependencies":[],"frontmatter":{"title":"Functions for other notebooks to use","content_includes_title":false,"kernelspec":{"name":"python3","display_name":"Python 3 (ipykernel)","language":"python"},"authors":[{"nameParsed":{"literal":"The Project Pythia Community","given":"The Project Pythia","family":"Community"},"name":"The Project Pythia Community","id":"contributors-myst-generated-uid-0"}],"open_access":true,"license":{"content":{"id":"CC-BY-4.0","url":"https://creativecommons.org/licenses/by/4.0/","name":"Creative Commons Attribution 4.0 International","free":true,"CC":true},"code":{"id":"Apache-2.0","url":"https://opensource.org/licenses/Apache-2.0","name":"Apache License 2.0","free":true,"osi":true}},"github":"https://github.com/projectpythia/xbatcher-deep-learning","copyright":"2024","affiliations":[{"id":"UAlbany","name":"University at Albany (SUNY)","department":"Atmospheric and Environmental Sciences","url":"https://www.albany.edu/daes"},{"id":"CISL","name":"NSF National Center for Atmospheric Research","department":"Computational and Information Systems Lab","url":"https://www.cisl.ucar.edu"},{"id":"Unidata","name":"NSF Unidata","url":"https://www.unidata.ucar.edu"},{"id":"Argonne","name":"Argonne National Laboratory","department":"Environmental Science Division","url":"https://www.anl.gov/evs"},{"id":"CarbonPlan","name":"CarbonPlan","url":"https://carbonplan.org"},{"id":"NVIDIA","name":"NVIDIA Corporation","url":"https://www.nvidia.com/"}],"numbering":{"title":{"offset":1}},"edit_url":"https://github.com/projectpythia/xbatcher-deep-learning/blob/main/notebooks/functions.ipynb","exports":[{"format":"ipynb","filename":"functions.ipynb","url":"/xbatcher-deep-learning/build/functions-54692677281e062e39c8f55cf7778056.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import xarray as xr\nimport numpy as np\nimport xbatcher\nfrom xbatcher.loaders.torch import MapDataset\nimport torch\n\ndef _get_output_array_size(\n    bgen: xbatcher.BatchGenerator,\n    output_tensor_dim: dict[str, int],\n    new_dim: list[str],\n    resample_dim: list[str]\n):\n    output_size = {}\n    for key, size in output_tensor_dim.items():\n        if key in new_dim:\n            # This is a new axis, size is determined\n            # by the tensor size.\n            output_size[key] = output_tensor_dim[key]\n        else:\n            # This is a resampled axis, determine the new size\n            # by the ratio of the batchgen window to the tensor size.\n            window_size = bgen.input_dims[key]\n            tensor_size = output_tensor_dim[key]\n            resample_ratio = tensor_size / window_size\n    \n            temp_output_size = bgen.ds.sizes[key] * resample_ratio\n            assert temp_output_size.is_integer()\n            output_size[key] = int(temp_output_size)\n    return output_size","key":"hNO7oz1AKu"},{"type":"output","id":"YL16YhmFcbHjSPcjLOI7Y","data":[],"key":"TQK0xo0qug"}],"key":"iGLshN8FB0"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"def predict_on_array(\n    dataset: MapDataset,\n    model: torch.nn.Module,\n    output_tensor_dim: dict[str, int],\n    new_dim: list[str],\n    resample_dim: list[str],\n    batch_size: int=16\n):\n    # Set up output array\n    output_size = _get_output_array_size(dataset.X_generator, output_tensor_dim, new_dim, resample_dim)\n            \n    output_da = xr.DataArray(\n        data=np.zeros(tuple(output_size.values())),\n        dims=tuple(output_size.keys())\n    )\n    output_n = xr.full_like(output_da, 0)\n    \n    # Prepare data laoder\n    loader = torch.utils.data.DataLoader(dataset, batch_size=batch_size)\n\n    # Iterate over each batch\n    for i, batch in enumerate(loader):\n        out_batch = model(batch).detach().numpy()\n\n        # Iterate over each example in the batch\n        for ib in range(out_batch.shape[0]):\n            # Get the slice object associated with this example\n            old_indexer = dataset.X_generator._batch_selectors.selectors[(i*batch_size)+ib][0]\n            # Only index into axes that are resampled, rescaling the bounds\n            new_indexer = dict()\n            for key in old_indexer:\n                if key in resample_dim:\n                    resample_ratio = output_tensor_dim[key] / dataset.X_generator.input_dims[key]\n                    new_indexer[key] = slice(\n                        int(old_indexer[key].start * resample_ratio),\n                        int(old_indexer[key].stop * resample_ratio)\n                    )\n            \n            output_da.loc[new_indexer] += out_batch[ib, ...]\n            output_n.loc[new_indexer] += 1\n    \n    # TODO aggregate output\n    return output_da","key":"VzDoV6cQXs"},{"type":"output","id":"9kuB2ncFz7H1igPp_hN0s","data":[],"key":"wwsJTvQzsm"}],"key":"Ix76X3jqKv"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"from dummy_models import *","key":"zME17nboaA"},{"type":"output","id":"JbTV5GD3tl7M0JwhGEDlX","data":[],"key":"vX2k2NcS9h"}],"key":"qZfzlTD95i"}],"key":"ietKXPEufM"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Infer model on array","url":"/notebooks/inference-testing","group":"Testing model inference"}}},"domain":"http://localhost:3000"}